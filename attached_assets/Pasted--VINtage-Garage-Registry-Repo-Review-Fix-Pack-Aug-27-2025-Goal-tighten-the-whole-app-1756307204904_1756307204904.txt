# VINtage Garage Registry — Repo Review & Fix Pack (Aug 27, 2025)

> **Goal:** tighten the whole app: fix breakages (CORS, duplicate VINs, schema drift), add safeguards, and ship a clean, production‑ready baseline. Everything below is copy‑pasteable into Replit. Where a file already exists, replace it fully with the versions here. If a path doesn’t exist yet, create it.

---

## What I scanned / assumed from the repo

* Monorepo‑style layout: `client/`, `server/`, `shared/` plus drizzle config and Tailwind setup.
* TypeScript throughout.
* Drizzle ORM schema + migrations.
* Replit deployment + Replit Auth in play (session‑style on the app), prior experiments with JWT.
* NHTSA VIN decode (vPIC) planned/used; CORS pain was reported.

> If any folder names differ slightly, keep the structure but place files in the closest match.

---

## Top Priorities (P0)

1. **CORS + Preflight + Proxy the NHTSA calls**

   * Don’t call vPIC from the browser (CORS varies). Proxy via your server (`/api/v1/vins/:vin/decode`).
   * Use an **allowlist** from `ALLOW_ORIGINS` env var and handle preflight explicitly.

2. **Prevent duplicate VINs across the entire system**

   * Enforce a **unique index on `vehicles.vin`** (global uniqueness) and guard in the API + UI.

3. **Schema drift (“`ai_insights`” field) & safer queries**

   * Add the column once at the DB level, mark it optional in Drizzle, and default `NULL`.
   * In code, always `coalesce`/fallback when reading it.

---

## Priorities (P1)

* Centralized **env validation** (zod) with helpful errors.
* Central **error handler**; never leak stack traces in production.
* **Rate limiting** + **helmet** + request **logging**.
* Input **validation** (zod) for all write endpoints.
* **Auth middleware** helpers (works with Replit Auth now; simple upgrade path if you later swap).

---

## Priorities (P2)

* **Responsive AppLayout** on the client, mobile defaults, and accessible breadcrumbs.
* Frontend **VIN check on blur** with debounced API call.
* Vite **dev proxy** to avoid local CORS while developing.
* Minimal **Vitest** smoke tests for VIN validation + duplicate check path.

---

## 1) Environment validation (server)

Create `server/src/env.ts`:

```ts
// server/src/env.ts
import { z } from "zod";

const EnvSchema = z.object({
  NODE_ENV: z.enum(["development", "test", "production"]).default("development"),
  PORT: z.coerce.number().default(8080),
  DATABASE_URL: z.string().min(1, "DATABASE_URL is required"),
  SESSION_SECRET: z.string().min(16, "SESSION_SECRET should be >=16 chars"),
  ALLOW_ORIGINS: z
    .string()
    .default("http://localhost:5173,http://127.0.0.1:5173"),
  OPENAI_API_KEY: z.string().optional(),
  REDIS_URL: z.string().optional(),
});

export const env = EnvSchema.parse(process.env);
export const isProd = env.NODE_ENV === "production";
export const allowedOrigins = env.ALLOW_ORIGINS.split(",").map(s => s.trim()).filter(Boolean);
```

Add `.env.example` keys (update your file):

```bash
NODE_ENV=development
PORT=8080
DATABASE_URL=postgres://user:pass@host:5432/db
SESSION_SECRET=replace_me_with_long_random
ALLOW_ORIGINS=http://localhost:5173,https://your-repl-url.replit.app
OPENAI_API_KEY=
REDIS_URL=
```

---

## 2) Express app hardening + CORS (server)

Replace/create `server/src/app.ts`:

```ts
// server/src/app.ts
import express from "express";
import helmet from "helmet";
import compression from "compression";
import morgan from "morgan";
import rateLimit from "express-rate-limit";
import cors from "cors";
import "express-async-errors";
import { allowedOrigins, isProd } from "./env";
import { router as vinsRouter } from "./routes/vins";
import { router as vehiclesRouter } from "./routes/vehicles";

export function buildApp() {
  const app = express();

  // Security & perf
  app.use(helmet({
    crossOriginEmbedderPolicy: false,
    contentSecurityPolicy: false, // keep simple for APIs
  }));
  app.use(compression());
  app.use(morgan(isProd ? "combined" : "dev"));

  // JSON body
  app.use(express.json({ limit: "1mb" }));

  // CORS
  const corsOptions: cors.CorsOptions = {
    origin(origin, cb) {
      if (!origin) return cb(null, true); // allow server-to-server & curl
      if (allowedOrigins.includes(origin)) return cb(null, true);
      return cb(new Error(`CORS: origin ${origin} not allowed`));
    },
    credentials: true,
    methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    allowedHeaders: [
      "Content-Type",
      "Authorization",
      "X-Requested-With",
      "Accept",
    ],
    exposedHeaders: ["ETag"],
    maxAge: 86400,
  };
  app.use((req, res, next) => {
    // Handle preflight early for any /api route
    if (req.method === "OPTIONS") return cors(corsOptions)(req, res, next);
    return cors(corsOptions)(req, res, next);
  });

  // Health
  app.get("/api/health", (_req, res) => res.json({ ok: true }));

  // Routes
  app.use("/api/v1/vins", vinsRouter);
  app.use("/api/v1/vehicles", vehiclesRouter);

  // 404
  app.use((_req, res) => res.status(404).json({ error: "Not Found" }));

  // Error handler
  app.use((err: any, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
    const code = typeof err?.status === "number" ? err.status : 500;
    const msg = isProd && code === 500 ? "Internal Server Error" : String(err?.message || err);
    if (!isProd) console.error(err);
    res.status(code).json({ error: msg });
  });

  // Basic rate limit across API surface
  app.use("/api/", rateLimit({ windowMs: 15 * 60_000, max: 300 }));

  return app;
}
```

Create `server/src/index.ts` to start the server:

```ts
// server/src/index.ts
import { env } from "./env";
import { buildApp } from "./app";

const app = buildApp();
app.listen(env.PORT, () => {
  console.log(`Server listening on :${env.PORT}`);
});
```

Add script in root `package.json` (if not already):

```json
{
  "scripts": {
    "server": "tsx server/src/index.ts"
  }
}
```

---

## 3) Drizzle schema + migrations (server)

Create/replace `server/src/db/schema.ts`:

```ts
// server/src/db/schema.ts
import { pgTable, text, uuid, timestamp, jsonb, index, unique } from "drizzle-orm/pg-core";

export type AiInsights = {
  summary: string;
  funFact?: string;
  market?: {
    estAuctionPriceUSD?: number;
    compsNote?: string;
  };
};

export const vehicles = pgTable(
  "vehicles",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    vin: text("vin").notNull(),
    nickname: text("nickname"),
    year: text("year"),
    make: text("make"),
    model: text("model"),
    currentOwnerId: text("current_owner_id").notNull(),
    aiInsights: jsonb("ai_insights").$type<AiInsights | null>().default(null),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
  },
  (t) => ({
    vinUnique: unique("vehicles_vin_unique").on(t.vin),
    ownerVinIdx: index("vehicles_owner_vin_idx").on(t.currentOwnerId, t.vin),
  })
);
```

Add a safe migration (Postgres) `server/drizzle/20250827_add_unique_aiinsights.sql`:

```sql
-- Add ai_insights column if missing
ALTER TABLE vehicles
  ADD COLUMN IF NOT EXISTS ai_insights jsonb;

-- Globally enforce VIN uniqueness
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'vehicles_vin_unique'
  ) THEN
    ALTER TABLE vehicles ADD CONSTRAINT vehicles_vin_unique UNIQUE (vin);
  END IF;
END$$;

-- Helpful index for lookups
CREATE INDEX IF NOT EXISTS vehicles_owner_vin_idx ON vehicles (current_owner_id, vin);
```

> **If using SQLite:** create a separate migration with `CREATE UNIQUE INDEX IF NOT EXISTS vehicles_vin_unique ON vehicles(vin);` and `ALTER TABLE vehicles ADD COLUMN ai_insights TEXT;` (store JSON as text) then handle parsing in code.

---

## 4) VIN utilities (server)

Create `server/src/lib/vin.ts`:

```ts
// server/src/lib/vin.ts
export function sanitizeVin(input: string): string {
  return (input || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 17);
}

export function isPotentialVin(input: string): boolean {
  const v = sanitizeVin(input);
  return v.length === 17 && !/[IOQ]/.test(v); // real VINs exclude I,O,Q
}
```

---

## 5) vPIC proxy + AI insights endpoints (server)

Create `server/src/routes/vins.ts`:

```ts
// server/src/routes/vins.ts
import { Router } from "express";
import fetch from "node-fetch";
import { sanitizeVin, isPotentialVin } from "../lib/vin";
import { promptInsights } from "../services/insights";

export const router = Router();

// Proxy to NHTSA vPIC to avoid CORS from the browser
router.get(":vin/decode", async (req, res) => {
  const vin = sanitizeVin(String(req.params.vin));
  if (!isPotentialVin(vin)) return res.status(400).json({ error: "Invalid VIN" });

  const url = `https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVin/${vin}?format=json`;
  const r = await fetch(url, { headers: { "user-agent": "VINtage/1.0" } });
  if (!r.ok) return res.status(502).json({ error: `vPIC error: ${r.status}` });
  const data = await r.json();

  // Optionally shrink & normalize the response
  const result = (data?.Results || []).reduce((acc: any, row: any) => {
    if (row?.Variable && row?.Value) acc[row.Variable] = row.Value;
    return acc;
  }, {} as Record<string, string>);

  res.setHeader("Cache-Control", "public, max-age=3600");
  return res.json({ vin, result });
});

// AI insights from VIN + decoded data
router.get(":vin/insights", async (req, res) => {
  const vin = sanitizeVin(String(req.params.vin));
  if (!isPotentialVin(vin)) return res.status(400).json({ error: "Invalid VIN" });

  const decoded = await (await fetch(`https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVin/${vin}?format=json`)).json();
  const summary = await promptInsights(vin, decoded);
  return res.json({ vin, insights: summary });
});
```

Create `server/src/services/insights.ts`:

```ts
// server/src/services/insights.ts
import { env } from "../env";

export async function promptInsights(vin: string, decoded: unknown) {
  if (!env.OPENAI_API_KEY) {
    return {
      summary: "Set OPENAI_API_KEY to enable AI insights.",
      funFact: undefined,
      market: undefined,
    };
  }

  // Lazy import to avoid bundling when key is missing
  const OpenAI = (await import("openai")).default;
  const client = new OpenAI({ apiKey: env.OPENAI_API_KEY });

  const sys = `You are an automotive analyst. Write concise, factual insights. Use short bullets.`;
  const user = `VIN: ${vin}\nDecoded (may be partial): ${JSON.stringify(decoded).slice(0, 4000)}`;

  const resp = await client.chat.completions.create({
    model: "gpt-4o-mini", // small, fast model; swap if desired
    temperature: 0.2,
    messages: [
      { role: "system", content: sys },
      {
        role: "user",
        content:
          user +
          "\n\nReturn JSON with keys: summary (string), funFact (string?), market (object with estAuctionPriceUSD:number?, compsNote:string?).",
      },
    ],
    response_format: { type: "json_object" },
  });

  try {
    return JSON.parse(resp.choices[0]?.message?.content || "{}");
  } catch {
    return { summary: "Insight generation failed to parse." };
  }
}
```

> **Note:** The insights endpoint is optional. If you don’t want to enable OpenAI yet, leave `OPENAI_API_KEY` empty and the API will respond with a friendly message.

---

## 6) Vehicles API with duplicate VIN prevention (server)

Create `server/src/routes/vehicles.ts`:

```ts
// server/src/routes/vehicles.ts
import { Router } from "express";
import { z } from "zod";
import { eq } from "drizzle-orm";
import { vehicles } from "../db/schema";
import { db } from "../db/client"; // your drizzle client import
import { sanitizeVin, isPotentialVin } from "../lib/vin";

const CreateVehicle = z.object({
  vin: z.string(),
  nickname: z.string().optional(),
  year: z.string().optional(),
  make: z.string().optional(),
  model: z.string().optional(),
});

export const router = Router();

// Quick existence check used by the UI
router.get("/check", async (req, res) => {
  const vin = sanitizeVin(String(req.query.vin || ""));
  if (!isPotentialVin(vin)) return res.json({ vin, exists: false });
  const [row] = await db.select().from(vehicles).where(eq(vehicles.vin, vin)).limit(1);
  return res.json({ vin, exists: Boolean(row) });
});

router.post("/", async (req, res) => {
  const parsed = CreateVehicle.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });

  const vin = sanitizeVin(parsed.data.vin);
  if (!isPotentialVin(vin)) return res.status(400).json({ error: "Invalid VIN" });

  // Server-side guard
  const [existing] = await db.select().from(vehicles).where(eq(vehicles.vin, vin)).limit(1);
  if (existing) return res.status(409).json({ error: "This VIN is already registered." });

  try {
    const [inserted] = await db
      .insert(vehicles)
      .values({
        vin,
        nickname: parsed.data.nickname || null,
        year: parsed.data.year || null,
        make: parsed.data.make || null,
        model: parsed.data.model || null,
        currentOwnerId: "replit-auth-user" /* replace with your session user id */,
      })
      .returning();

    return res.status(201).json({ vehicle: inserted });
  } catch (err: any) {
    // Handle unique constraint from different backends
    const msg = String(err?.message || err);
    const isUnique =
      msg.includes("vehicles_vin_unique") ||
      msg.includes("unique constraint") ||
      msg.includes("SQLITE_CONSTRAINT_UNIQUE") ||
      msg.includes("23505");
    if (isUnique) return res.status(409).json({ error: "This VIN is already registered." });
    throw err;
  }
});
```

> Replace `db` import with your actual Drizzle client path, e.g., `server/src/db/client.ts`.

---

## 7) Client API helper + VIN duplicate UX (client)

Create `client/src/lib/api.ts`:

```ts
// client/src/lib/api.ts
export async function api<T>(path: string, init?: RequestInit): Promise<T> {
  const res = await fetch(path, {
    credentials: "include",
    headers: { "Content-Type": "application/json" },
    ...(init || {}),
  });
  if (!res.ok) throw new Error(`${res.status}: ${await res.text()}`);
  return res.json();
}
```

Create `client/src/features/vehicles/AddVehicleForm.tsx`:

```tsx
import { useEffect, useMemo, useState } from "react";
import { api } from "../../lib/api";

export function AddVehicleForm({ onCreated }: { onCreated?: () => void }) {
  const [vin, setVin] = useState("");
  const [nickname, setNickname] = useState("");
  const [checking, setChecking] = useState(false);
  const [exists, setExists] = useState<boolean | null>(null);
  const isValid = useMemo(() => /^[A-HJ-NPR-Z0-9]{17}$/.test(vin), [vin]);

  useEffect(() => {
    const t = setTimeout(async () => {
      if (!isValid) return setExists(null);
      setChecking(true);
      try {
        const data = await api<{ vin: string; exists: boolean }>(`/api/v1/vehicles/check?vin=${vin}`);
        setExists(data.exists);
      } catch {
        setExists(null);
      } finally {
        setChecking(false);
      }
    }, 300);
    return () => clearTimeout(t);
  }, [vin, isValid]);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!isValid || exists) return;
    await api(`/api/v1/vehicles`, {
      method: "POST",
      body: JSON.stringify({ vin, nickname }),
    });
    onCreated?.();
  }

  return (
    <form onSubmit={onSubmit} className="space-y-3">
      <div>
        <label className="block text-sm font-medium">VIN</label>
        <input
          className="border rounded px-3 py-2 w-full"
          value={vin}
          onChange={(e) => setVin(e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 17))}
          placeholder="17‑char VIN"
        />
        {checking && <p className="text-xs opacity-70 mt-1">Checking…</p>}
        {exists === true && (
          <p className="text-xs text-red-600 mt-1">This VIN is already registered.</p>
        )}
        {exists === false && <p className="text-xs text-green-600 mt-1">Available</p>}
      </div>

      <div>
        <label className="block text-sm font-medium">Nickname (optional)</label>
        <input
          className="border rounded px-3 py-2 w-full"
          value={nickname}
          onChange={(e) => setNickname(e.target.value)}
        />
      </div>

      <button
        type="submit"
        className="bg-black text-white rounded px-4 py-2 disabled:opacity-50"
        disabled={!isValid || exists === true}
      >
        Add Vehicle
      </button>
    </form>
  );
}
```

Create a tiny decoder page `client/src/pages/VINDecoder.tsx`:

```tsx
import { useState } from "react";
import { api } from "../lib/api";

export default function VINDecoder() {
  const [vin, setVin] = useState("");
  const [data, setData] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);

  async function decode() {
    setError(null);
    setData(null);
    try {
      const out = await api(`/api/v1/vins/${vin}/decode`);
      setData(out);
    } catch (e: any) {
      setError(String(e?.message || e));
    }
  }

  return (
    <div className="max-w-2xl mx-auto p-4 space-y-3">
      <h1 className="text-xl font-semibold">VIN Decoder</h1>
      <div className="flex gap-2">
        <input
          value={vin}
          onChange={(e) => setVin(e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 17))}
          className="border rounded px-3 py-2 flex-1"
          placeholder="Enter VIN"
        />
        <button onClick={decode} className="bg-black text-white rounded px-4">Decode</button>
      </div>
      {error && <pre className="text-red-600 text-sm">{error}</pre>}
      {data && <pre className="text-xs bg-gray-50 border p-3 rounded overflow-auto">{JSON.stringify(data, null, 2)}</pre>}
    </div>
  );
}
```

Add a route to your client router to mount `VINDecoder`.

---

## 8) Vite dev proxy (client)

Append/replace your `vite.config.ts` dev server section:

```ts
// vite.config.ts (excerpt)
export default defineConfig({
  server: {
    port: 5173,
    proxy: {
      "/api": {
        target: "http://localhost:8080",
        changeOrigin: true,
      },
    },
  },
});
```

This avoids local CORS entirely in dev.

---

## 9) Shared types (optional)

Create `shared/types.ts` to align front/back:

```ts
export type Vehicle = {
  id: string;
  vin: string;
  nickname?: string | null;
  year?: string | null;
  make?: string | null;
  model?: string | null;
  currentOwnerId: string;
  createdAt: string;
  updatedAt: string;
};
```

Use this on both sides for consistent typing.

---

## 10) Quick tests (server)

Create `server/test/vin.test.ts` (Vitest):

```ts
import { describe, it, expect } from "vitest";
import { sanitizeVin, isPotentialVin } from "../src/lib/vin";

describe("vin utils", () => {
  it("sanitizes and uppercases", () => {
    expect(sanitizeVin("wa1a-2b3c4d5e6f7g8")).toBe("WA1A2B3C4D5E6F7G8".slice(0, 17));
  });
  it("validates format", () => {
    expect(isPotentialVin("1HGCM82633A004352")).toBe(true);
    expect(isPotentialVin("1HGCM82633A00435I")).toBe(false); // I not allowed
  });
});
```

Add test script:

```json
{
  "scripts": {
    "test": "vitest run"
  }
}
```

---

## 11) Auth note (keep today, future‑proof for tomorrow)

* Keep **Replit Auth** as your session source today. Wrap it with small helpers: `requireAuth`, `optionalAuth` that set `req.user`.
* If/when you switch to JWT later, only the helpers change — routes remain intact.

---

## 12) Deployment & ops checklist

* [ ] Run migrations: **Drizzle** (or raw SQL) for `ai_insights` + `vehicles_vin_unique`.
* [ ] Set `ALLOW_ORIGINS` to your production app domain(s).
* [ ] Confirm `vite` dev proxy works locally; in prod, client and server share domain or use the API domain directly.
* [ ] Verify health at `/api/health`.
* [ ] Smoke test: add a VIN, then try again → should 409.
* [ ] Decode VIN page returns normalized vPIC data.
* [ ] If `OPENAI_API_KEY` is present, `/api/v1/vins/:vin/insights` returns JSON.

---

## 13) Manual verification plan (15 minutes)

1. **CORS**: From the browser devtools, ensure no preflight failures when hitting `/api/...`.
2. **Duplicate protection**: Attempt to add the same VIN twice → second attempt must return 409.
3. **Schema**: Insert with `ai_insights = NULL`; later call insights → update column; SELECT should not crash on missing field.
4. **vPIC**: Try a real VIN; confirm year/make/model present in the mapped result.
5. **Rate limit**: Hammer `/api/health` >300 in 15 min → 429s appear.

---

## 14) Nice‑to‑haves (soon)

* **ETag caching** on `/vins/:vin/decode` responses.
* **Redis cache** for vPIC responses (1h TTL) to reduce latency and API load.
* **Pino** instead of `morgan` for structured logs.
* **Husky** pre‑commit: `eslint --max-warnings=0 && tsc -p tsconfig.json && vitest run`.
* **Better vPIC mapping** (surface common keys like `Make`, `Model Year`, `Model`).

---

## TL;DR

* Proxy vPIC via the server and harden **CORS**.
* Add **global VIN uniqueness** (DB + API + UI guard).
* Fix **schema drift** by making `ai_insights` optional w/ a migration.
* Wrap env, errors, and inputs in **zod** + proper middleware.
* Ship a small, focused **decoder page** and a **duplicate‑aware Add Vehicle form** to confirm the flow end‑to‑end.
