# Email + Password Auth (Drop‑in) — VINtage Garage

> Copy/paste pack to add classic username/email + password alongside Google OAuth.

---

## 0) Install deps

```bash
# server
pnpm add argon2 jsonwebtoken zod nanoid
# client
pnpm add zod
```

Add to **`.env.example`**:

```env
JWT_SECRET=replace_me
JWT_REFRESH_SECRET=replace_me
FRONTEND_BASE=http://localhost:5173
# For password reset links
APP_NAME=VINtage Garage
APP_FROM_EMAIL=no-reply@vintagegarage.app
```

---

## 1) Shared validation

**`/shared/authSchemas.ts`**

```ts
import { z } from "zod";
export const Email = z.string().email().max(254);
export const Password = z.string().min(8).max(128);
export const RegisterInput = z.object({ email: Email, password: Password, handle: z.string().min(3).max(20) });
export const LoginInput = z.object({ email: Email, password: Password });
export const ResetStartInput = z.object({ email: Email });
export const ResetFinishInput = z.object({ token: z.string().min(16), password: Password });
```

---

## 2) DB additions (Drizzle)

**`/server/db/schema.auth.ts`**

```ts
import { pgTable, serial, varchar, integer, timestamp } from "drizzle-orm/pg-core";
import { users } from "./schema";

export const passwordResets = pgTable("password_resets", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  token: varchar("token", { length: 120 }).notNull().unique(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});
```

> Ensure your `users` table has `hash TEXT NOT NULL` (you already do in our plan). If not, add it.

---

## 3) Server auth routes

**`/server/http/auth.local.ts`**

```ts
import { Router } from "express";
import argon2 from "argon2";
import { nanoid } from "nanoid";
import { db } from "../db/client";
import { users } from "../db/schema";
import { passwordResets } from "../db/schema.auth";
import { eq } from "drizzle-orm";
import { RegisterInput, LoginInput, ResetStartInput, ResetFinishInput } from "../../shared/authSchemas";
import jwt from "jsonwebtoken";

const router = Router();

function signAccess(u: any) {
  return jwt.sign({ id: u.id, email: u.email }, process.env.JWT_SECRET!, { expiresIn: "1h" });
}

// REGISTER
router.post("/auth/register", async (req, res) => {
  const body = RegisterInput.safeParse(req.body);
  if (!body.success) return res.status(400).json({ ok: false, error: body.error.flatten() });
  const { email, password, handle } = body.data;
  const existing = await db.query.users.findFirst({ where: (u, { eq }) => eq(u.email, email.toLowerCase()) });
  if (existing) return res.status(409).json({ ok: false, error: { message: "Email already registered" } });
  const hash = await argon2.hash(password);
  const inserted = await db.insert(users).values({ email: email.toLowerCase(), handle, hash }).returning();
  const u = inserted[0];
  const token = signAccess(u);
  res.json({ ok: true, token, user: { id: u.id, email: u.email, handle: u.handle } });
});

// LOGIN
router.post("/auth/login", async (req, res) => {
  const body = LoginInput.safeParse(req.body);
  if (!body.success) return res.status(400).json({ ok: false, error: body.error.flatten() });
  const { email, password } = body.data;
  const u = await db.query.users.findFirst({ where: (t, { eq }) => eq(t.email, email.toLowerCase()) });
  if (!u) return res.status(401).json({ ok: false, error: { message: "Invalid credentials" } });
  if (!u.hash || !(await argon2.verify(u.hash, password)))
    return res.status(401).json({ ok: false, error: { message: "Invalid credentials" } });
  const token = signAccess(u);
  res.json({ ok: true, token, user: { id: u.id, email: u.email, handle: u.handle } });
});

// START RESET (email stub)
router.post("/auth/reset/start", async (req, res) => {
  const body = ResetStartInput.safeParse(req.body);
  if (!body.success) return res.status(400).json({ ok: false, error: body.error.flatten() });
  const email = body.data.email.toLowerCase();
  const u = await db.query.users.findFirst({ where: (t, { eq }) => eq(t.email, email) });
  if (!u) return res.json({ ok: true }); // do not leak existence
  const token = nanoid(40);
  const expires = new Date(Date.now() + 1000 * 60 * 30); // 30m
  await db.insert(passwordResets).values({ userId: u.id, token, expiresAt: expires });
  // TODO: send email with link
  console.log(`[reset] send link to ${email}: ${process.env.FRONTEND_BASE}/reset?token=${token}`);
  res.json({ ok: true });
});

// FINISH RESET
router.post("/auth/reset/finish", async (req, res) => {
  const body = ResetFinishInput.safeParse(req.body);
  if (!body.success) return res.status(400).json({ ok: false, error: body.error.flatten() });
  const row = await db.query.passwordResets.findFirst({ where: (t, { eq }) => eq(t.token, body.data.token) });
  if (!row || row.expiresAt < new Date()) return res.status(400).json({ ok: false, error: { message: "Invalid/expired token" } });
  const hash = await argon2.hash(body.data.password);
  await db.update(users).set({ hash }).where(eq(users.id, row.userId));
  // delete token (single-use)
  // @ts-ignore
  await db.delete(passwordResets).where(eq(passwordResets.id, row.id));
  res.json({ ok: true });
});

export default router;
```

Mount in your server index:

```ts
import authLocalRouter from "./auth.local";
app.use(authLocalRouter);
```

---

## 4) Client: forms with Zod

**`/client/src/pages/Register.tsx`**

```tsx
import { useState } from "react";
import { z } from "zod";
const Schema = z.object({ email: z.string().email(), handle: z.string().min(3).max(20), password: z.string().min(8), confirm: z.string().min(8) })
  .refine((d) => d.password === d.confirm, { message: "Passwords must match", path: ["confirm"] });

export default function Register() {
  const [err, setErr] = useState<string | null>(null);

  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const fd = new FormData(e.currentTarget);
    const data = {
      email: String(fd.get("email")),
      handle: String(fd.get("handle")),
      password: String(fd.get("password")),
      confirm: String(fd.get("confirm")),
    };
    const parsed = Schema.safeParse(data);
    if (!parsed.success) return setErr(parsed.error.issues[0].message);
    const res = await fetch(import.meta.env.VITE_API_BASE + "/auth/register", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(parsed.data) });
    const j = await res.json();
    if (!res.ok || !j.ok) return setErr(j.error?.message || "Registration failed");
    localStorage.setItem("vg.jwt", j.token);
    window.location.href = "/";
  }

  return (
    <main className="min-h-screen grid place-items-center bg-slate-50 p-6">
      <form onSubmit={onSubmit} className="w-full max-w-sm bg-white border rounded-2xl p-6 shadow-sm space-y-3">
        <h1 className="text-xl font-semibold">Create account</h1>
        {err && <div className="text-sm text-red-600">{err}</div>}
        <input name="email" type="email" placeholder="Email" className="w-full border rounded-lg px-3 py-2" required />
        <input name="handle" placeholder="Username" className="w-full border rounded-lg px-3 py-2" required />
        <input name="password" type="password" placeholder="Password" className="w-full border rounded-lg px-3 py-2" required />
        <input name="confirm" type="password" placeholder="Confirm password" className="w-full border rounded-lg px-3 py-2" required />
        <button className="w-full bg-slate-900 text-white rounded-lg py-2">Create account</button>
        <a href="/signin" className="text-sm text-slate-600 hover:underline">Have an account? Sign in</a>
      </form>
    </main>
  );
}
```

**`/client/src/pages/SignIn.tsx`**

```tsx
import { useState } from "react";
export default function SignIn() {
  const [err, setErr] = useState<string | null>(null);
  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const fd = new FormData(e.currentTarget);
    const payload = { email: String(fd.get("email")), password: String(fd.get("password")) };
    const res = await fetch(import.meta.env.VITE_API_BASE + "/auth/login", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(payload) });
    const j = await res.json();
    if (!res.ok || !j.ok) return setErr(j.error?.message || "Login failed");
    localStorage.setItem("vg.jwt", j.token);
    window.location.href = "/";
  }
  return (
    <main className="min-h-screen grid place-items-center bg-slate-50 p-6">
      <form onSubmit={onSubmit} className="w-full max-w-sm bg-white border rounded-2xl p-6 shadow-sm space-y-3">
        <h1 className="text-xl font-semibold">Sign in</h1>
        {err && <div className="text-sm text-red-600">{err}</div>}
        <input name="email" type="email" placeholder="Email" className="w-full border rounded-lg px-3 py-2" required />
        <input name="password" type="password" placeholder="Password" className="w-full border rounded-lg px-3 py-2" required />
        <button className="w-full bg-slate-900 text-white rounded-lg py-2">Sign in</button>
        <a href="/reset" className="text-sm text-slate-600 hover:underline">Forgot password?</a>
      </form>
    </main>
  );
}
```

**`/client/src/pages/Reset.tsx`**

```tsx
export function ResetStart() {
  return (
    <main className="min-h-screen grid place-items-center bg-slate-50 p-6">
      <form className="w-full max-w-sm bg-white border rounded-2xl p-6 shadow-sm space-y-3" onSubmit={async (e) => {
        e.preventDefault();
        const fd = new FormData(e.currentTarget as HTMLFormElement);
        await fetch(import.meta.env.VITE_API_BASE + "/auth/reset/start", { method: "POST", headers: {"Content-Type":"application/json"}, body: JSON.stringify({ email: String(fd.get("email")) }) });
        alert("If that email exists, a reset link was sent.");
      }}>
        <h1 className="text-xl font-semibold">Reset password</h1>
        <input name="email" type="email" placeholder="Email" className="w-full border rounded-lg px-3 py-2" required />
        <button className="w-full bg-slate-900 text-white rounded-lg py-2">Send link</button>
      </form>
    </main>
  );
}

export function ResetFinish() {
  const token = new URLSearchParams(location.search).get("token") || "";
  return (
    <main className="min-h-screen grid place-items-center bg-slate-50 p-6">
      <form className="w-full max-w-sm bg-white border rounded-2xl p-6 shadow-sm space-y-3" onSubmit={async (e) => {
        e.preventDefault();
        const fd = new FormData(e.currentTarget as HTMLFormElement);
        const payload = { token, password: String(fd.get("password")) };
        const r = await fetch(import.meta.env.VITE_API_BASE + "/auth/reset/finish", { method: "POST", headers: {"Content-Type":"application/json"}, body: JSON.stringify(payload) });
        if (r.ok) { alert("Password updated."); location.href = "/signin"; } else { alert("Reset failed"); }
      }}>
        <h1 className="text-xl font-semibold">Set new password</h1>
        <input name="password" type="password" placeholder="New password" className="w-full border rounded-lg px-3 py-2" required />
        <button className="w-full bg-slate-900 text-white rounded-lg py-2">Update password</button>
      </form>
    </main>
  );
}
```

---

## 5) Security notes

* Use **argon2id** (default) for hashing; never store plaintext.
* Rate‑limit `/auth/*` and add brute‑force protections.
* Consider httpOnly cookies instead of localStorage for production.

---

## 6) Minimal route guards (server)

Use your existing `requireAuth` to protect write endpoints; the email/password flow returns the same JWT format as Google OAuth.
