# VINtage Garage — Targeted Fixes: Dashboard Banner + AI Maintenance (Aug 27, 2025)

> **Goal:** Fix the disappearing banner on `/dashboard` after selecting a vehicle and get **AI Smart Maintenance** reliably rendering. Keep the current architecture intact. Drop‑in patches below.

---

## Overview of Likely Root Causes

* **Banner disappears** because it lives inside a route/component that **unmounts** on vehicle selection (or the layout remounts), or it’s controlled by local state wiped on navigation.
* **AI Maintenance empty** due to: missing `OPENAI_API_KEY`, a silent API error, schema drift for `ai_insights`, mismatched endpoint path, or the UI swallowing errors and rendering nothing.

---

## Part A — Persistent Global Banner (no more disappearing)

**Strategy:** Move banner state to a **global provider** with optional sessionStorage persistence and render the banner from a **stable AppLayout** that never unmounts across route changes.

### 1) Create Banner Provider

`client/src/providers/BannerProvider.tsx`

```tsx
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from "react";

export type BannerKind = "info" | "success" | "warning" | "error";
export type BannerMsg = { id: string; kind: BannerKind; text: string; sticky?: boolean; ttlMs?: number };

type Ctx = {
  banners: BannerMsg[];
  show: (m: Omit<BannerMsg, "id"> & { id?: string }) => string; // returns id
  hide: (id: string) => void;
  clear: () => void;
};

const BannerCtx = createContext<Ctx | null>(null);

const STORAGE_KEY = "vg.globalBanner";

export const BannerProvider: React.FC<{ children: React.ReactNode; persist?: boolean }>
= ({ children, persist = true }) => {
  const [banners, setBanners] = useState<BannerMsg[]>(() => {
    if (!persist) return [];
    try { return JSON.parse(sessionStorage.getItem(STORAGE_KEY) || "[]"); } catch { return []; }
  });

  useEffect(() => {
    if (!persist) return;
    try { sessionStorage.setItem(STORAGE_KEY, JSON.stringify(banners)); } catch {}
  }, [banners, persist]);

  // auto-expire non-sticky banners
  useEffect(() => {
    const timers = banners.map(b => {
      if (!b.ttlMs || b.sticky) return null;
      const t = setTimeout(() => setBanners(prev => prev.filter(x => x.id !== b.id)), b.ttlMs);
      return t;
    }).filter(Boolean) as NodeJS.Timeout[];
    return () => { timers.forEach(clearTimeout); };
  }, [banners]);

  const show: Ctx["show"] = useCallback((m) => {
    const id = m.id || `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
    setBanners(prev => [{ id, kind: m.kind, text: m.text, sticky: m.sticky, ttlMs: m.ttlMs ?? 6000 }, ...prev]);
    return id;
  }, []);

  const hide = useCallback((id: string) => setBanners(prev => prev.filter(b => b.id !== id)), []);
  const clear = useCallback(() => setBanners([]), []);

  const value = useMemo(() => ({ banners, show, hide, clear }), [banners, show, hide, clear]);

  return <BannerCtx.Provider value={value}>{children}</BannerCtx.Provider>;
};

export function useBanner() {
  const ctx = useContext(BannerCtx);
  if (!ctx) throw new Error("useBanner must be used within BannerProvider");
  return ctx;
}
```

### 2) Global Banner UI

`client/src/components/GlobalBanner.tsx`

```tsx
import React from "react";
import { useBanner } from "../providers/BannerProvider";

const KIND_CLASSES: Record<string, string> = {
  info: "bg-blue-50 text-blue-900 border-blue-200",
  success: "bg-green-50 text-green-900 border-green-200",
  warning: "bg-yellow-50 text-yellow-900 border-yellow-200",
  error: "bg-red-50 text-red-900 border-red-200",
};

export default function GlobalBanner() {
  const { banners, hide } = useBanner();
  if (!banners.length) return null;
  return (
    <div className="fixed top-0 inset-x-0 z-50 pointer-events-none">
      <div className="mx-auto max-w-6xl p-3 space-y-2">
        {banners.map(b => (
          <div key={b.id} className={`pointer-events-auto border rounded-lg p-3 shadow ${KIND_CLASSES[b.kind] || KIND_CLASSES.info}`}>
            <div className="flex items-start gap-3">
              <div className="font-medium capitalize">{b.kind}</div>
              <div className="flex-1 text-sm">{b.text}</div>
              <button className="text-sm underline" onClick={() => hide(b.id)}>Dismiss</button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 3) Make Layout Stable & Mount Banner Once

* Ensure your top‑level layout **does not unmount** across child routes. Avoid `key={location.pathname}` on the layout.
* Render `GlobalBanner` **inside** the app shell that wraps `<Outlet />`.

`client/src/AppLayout.tsx` (or equivalent)

```tsx
import React from "react";
import { Outlet } from "react-router-dom";
import GlobalBanner from "./components/GlobalBanner";

export default function AppLayout(){
  return (
    <div className="min-h-screen bg-white">
      <GlobalBanner />
      {/* your header / nav here */}
      <main className="pt-14"> {/* leave space for fixed banner if needed */}
        <Outlet />
      </main>
    </div>
  );
}
```

Wrap the **entire router** in the provider once:

`client/src/main.tsx` (or where you mount `<App />`)

```tsx
import React from "react";
import ReactDOM from "react-dom/client";
import { BannerProvider } from "./providers/BannerProvider";
import App from "./App";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <BannerProvider>
      <App />
    </BannerProvider>
  </React.StrictMode>
);
```

### 4) Use It When Vehicle Is Selected

In the component where you **set** the selected vehicle, show a success banner:

```tsx
import { useBanner } from "../providers/BannerProvider";

const { show } = useBanner();
// ... after selecting vehicle
show({ kind: "success", text: `Vehicle selected: ${vehicle.nickname ?? vehicle.vin}` });
```

**Result:** Banner is global, persists through navigation, and won’t disappear unless dismissed/expired.

---

## Part B — AI Smart Maintenance: Always Render Something

**Strategy:** Tighten the server endpoint + UI. Provide a clear fallback when the AI key isn’t present; surface **errors in the UI** (not silent). Optionally persist last successful insight in `ai_insights`.

### 1) Server Endpoint (no breaking changes)

`server/routes/maintenance.ts`

```ts
import { Router } from "express";
import fetch from "node-fetch";

export const maintenanceRouter = Router();

// Helper: trivial VIN sanitation
const sv = (s:string)=> (s||"").toUpperCase().replace(/[^A-Z0-9]/g,"").slice(0,17);

maintenanceRouter.get("/api/v1/maintenance/predict", async (req, res) => {
  try {
    const vin = sv(String(req.query.vin||""));
    const mileage = Number(req.query.mileage || 0) || undefined;
    if (vin.length !== 17) return res.status(400).json({ error: "Invalid VIN" });

    // Fetch decode (vPIC) to build context — you already have this proxy elsewhere
    const r = await fetch(`https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVin/${vin}?format=json`);
    const decoded = await r.json();

    // If no key, return deterministic fallback so UI always shows content
    if (!process.env.OPENAI_API_KEY) {
      return res.json({
        vin,
        source: "fallback",
        items: [
          { title: "Oil & Filter", when: "Next 5k mi", reason: "Standard interval; adjust for severe use." },
          { title: "Brake Inspection", when: "Next 10k mi", reason: "Age/mileage based; track pad/rotor wear." },
          { title: "Tire Rotation", when: "Next 5k–7k mi", reason: "Even wear; check alignment if cupping." }
        ],
        notes: "Set OPENAI_API_KEY to enable model‑driven personalization."
      });
    }

    // Lazy import to avoid startup crash if key missing
    const OpenAI = (await import("openai")).default;
    const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

    const sys = "You are an automotive service advisor. Return compact, practical maintenance suggestions as JSON.";
    const user = {
      vin,
      mileage: mileage ?? null,
      decoded: decoded?.Results ?? null
    };

    const resp = await client.chat.completions.create({
      model: "gpt-4o-mini",
      temperature: 0.2,
      messages: [
        { role: "system", content: sys },
        { role: "user", content: JSON.stringify(user) +
          "\nReturn JSON: {items:[{title,when,reason}], notes?}. Keep it brand-appropriate." }
      ],
      response_format: { type: "json_object" },
    });

    let data: any = {};
    try { data = JSON.parse(resp.choices[0]?.message?.content || "{}"); } catch {}

    // Never return empty; provide guard rails
    if (!data?.items?.length) {
      data = { items: [{ title: "General Inspection", when: "Next 5k mi", reason: "Baseline guidance." }], notes: "AI returned empty; using default." };
    }

    return res.json({ vin, source: "ai", ...data });
  } catch (e: any) {
    const msg = String(e?.message || e);
    // Surface a clean error so the UI can show a banner
    return res.status(500).json({ error: msg.slice(0, 300) });
  }
});
```

**Wire it** into your server bootstrapping (no route renames):

```ts
import { maintenanceRouter } from "./routes/maintenance";
app.use(maintenanceRouter);
```

> Optional: persist the returned object into `vehicles.ai_insights` for the selected vehicle and return that value to the client on subsequent loads.

### 2) Client Panel (never renders empty silently)

`client/src/components/SmartMaintenancePanel.tsx`

```tsx
import React, { useEffect, useState } from "react";

export default function SmartMaintenancePanel({ vin, mileage }: { vin: string; mileage?: number }){
  const [data, setData] = useState<any>(null);
  const [error, setError] = useState<string| null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (!vin || vin.length !== 17) return;
    let cancel = false;
    setLoading(true); setError(null);
    fetch(`/api/v1/maintenance/predict?vin=${vin}${mileage? `&mileage=${mileage}`:""}`)
      .then(async r => {
        if (!r.ok) throw new Error(await r.text());
        return r.json();
      })
      .then(j => { if (!cancel) setData(j); })
      .catch(e => { if (!cancel) setError(String(e)); })
      .finally(()=> { if (!cancel) setLoading(false); });
    return () => { cancel = true; };
  }, [vin, mileage]);

  if (!vin) return <div className="text-sm opacity-70">Select a vehicle to view maintenance recommendations.</div>;
  if (loading) return <div className="animate-pulse text-sm">Loading smart maintenance…</div>;
  if (error) return <div className="text-sm text-red-600">{String(error).slice(0,180)}</div>;
  if (!data) return null;

  return (
    <div className="border rounded-lg p-4">
      <div className="flex items-center justify-between">
        <h3 className="font-semibold">Smart Maintenance</h3>
        <span className="text-xs opacity-60">source: {data.source || "unknown"}</span>
      </div>
      <ul className="mt-3 space-y-2">
        {(data.items || []).map((it: any, i: number) => (
          <li key={i} className="border rounded p-2">
            <div className="font-medium">{it.title}</div>
            <div className="text-sm opacity-80">When: {it.when}</div>
            {it.reason && <div className="text-xs opacity-70">Why: {it.reason}</div>}
          </li>
        ))}
      </ul>
      {data.notes && <p className="text-xs opacity-70 mt-2">{data.notes}</p>}
    </div>
  );
}
```

Mount this panel inside your Dashboard and pass the selected vehicle’s VIN/mileage.

### 3) Bubble Errors to the Global Banner (nice UX)

In the parent where you render `SmartMaintenancePanel`, you can also show failures via the banner provider:

```tsx
import SmartMaintenancePanel from "./SmartMaintenancePanel";
import { useBanner } from "../providers/BannerProvider";

function Dashboard({ selectedVehicle }: { selectedVehicle?: { vin: string; mileage?: number } }){
  const { show } = useBanner();
  // Example: show banner when panel detects a failure via callback (if you wire one)
  // show({ kind: "error", text: "Maintenance service is currently unavailable.", sticky: false });
  return <SmartMaintenancePanel vin={selectedVehicle?.vin || ""} mileage={selectedVehicle?.mileage} />;
}
```

---

## Part C — Make Selected Vehicle Stable Across Routes

If selected vehicle is stored in local state of a page, it will reset on navigation. Use a **tiny persisted store**.

`client/src/stores/selectedVehicle.ts`

```ts
import { create } from "zustand";
import { persist } from "zustand/middleware";

type V = { id: string; vin: string; nickname?: string | null; mileage?: number };

type S = {
  vehicle: V | null;
  setVehicle: (v: V | null) => void;
};

export const useSelectedVehicle = create<S>()(persist((set) => ({
  vehicle: null,
  setVehicle: (v) => set({ vehicle: v })
}), { name: "vg.selectedVehicle" }));
```

Use it anywhere:

```tsx
import { useSelectedVehicle } from "../stores/selectedVehicle";
const { vehicle, setVehicle } = useSelectedVehicle();
```

This prevents banners/panels that depend on the selection from “vanishing” because of a page remount.

---

## Part D — Quick Diagnostics Checklist

1. **Layout remounting:** Ensure no `key={location.pathname}` on your layout container; that forces remount and clears banner state.
2. **CSS clash:** Parents with `overflow:hidden` + `position: sticky/fixed` banners sometimes hide content. Keep banner at `fixed` with high `z-index` (done above) and ensure header doesn’t overlay it.
3. **API visibility:** Hit `/api/v1/maintenance/predict?vin=<VIN>` directly. You must get either `source:"fallback"` JSON (no key) or `source:"ai"`. If it 500s, check server logs.
4. **Env:** Confirm `OPENAI_API_KEY` in env (no quotes/spaces). If using Replit Secrets, re‑deploy after updates.
5. **Schema:** If you later persist AI into `ai_insights`, keep the column **nullable** and guard all reads with null‑checks.
6. **Network:** Confirm the client calls the **server** endpoint, not the public vPIC domain (to avoid CORS).

---

## Optional — Persist AI Output to Vehicle (single place to read)

If you want to store last successful output:

`server/services/maintenancePersist.ts` (pseudo)

```ts
import { db } from "../db/client";
import { vehicles } from "../db/schema";
import { eq } from "drizzle-orm";

export async function saveAiInsights(vehicleId: string, payload: any){
  await db.update(vehicles).set({ aiInsights: payload, updatedAt: new Date() }).where(eq(vehicles.id, vehicleId));
}
```

Call `saveAiInsights` once the AI returns. On the client’s Dashboard, load from the vehicle row first, then revalidate with `/maintenance/predict` in the background.

---

## Acceptance Criteria

* Banner remains visible across navigation, dismissible, never silently disappears.
* `/api/v1/maintenance/predict` responds with JSON **even without** an API key.
* Smart Maintenance panel shows items or a clear error; never blank.
* Selected vehicle is preserved across pages and refreshes.

---

## Minimal Commands

```bash
# deps (client already has React/TW; add zustand if not present)
npm i zustand
# server already has express; no extra deps needed beyond node-fetch (if not installed)
npm i node-fetch
```

If zustand already exists, skip installing.

---

## What to send back after applying

* A screenshot or JSON sample from `/api/v1/maintenance/predict?vin=<VIN>`
* Confirmation that the banner persists when navigating Dashboard → Vehicle → Dashboard
* Whether the Dashboard uses the persisted `useSelectedVehicle` store successfully
