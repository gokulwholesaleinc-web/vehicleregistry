# Reply for Replit AI Agent — Implement the Review Plan

> **Context for the agent:** Our repo uses a flat `server/` (no `server/src/`). Please adapt the suggested code accordingly. We want an **incremental rollout**: CORS proxy first, then schema fixes, then uniqueness & AI. Maintain compatibility with existing photo uploads, vehicle edit flows, and dashboard.

---

## ✅ What to do (in order)

1. **Install deps** (server‑only; no client bundle impact):

```bash
npm i helmet compression morgan express-rate-limit cors zod node-fetch openai
```

2. **Create/replace files** below (paths assume `server/` root, not `server/src/`).

3. **Run migrations** per the plan (duplicate VIN scan → remediate → add unique constraint).

4. **Wire the frontend** to the new endpoints, add VIN duplicate checks in the form, and add the decoder page.

5. **Smoke test** using the checklist at the end.

---

## 1) Environment Validation

**`server/env.ts`**

```ts
import { z } from "zod";

const EnvSchema = z.object({
  NODE_ENV: z.enum(["development", "test", "production"]).default("development"),
  PORT: z.coerce.number().default(8080),
  DATABASE_URL: z.string().min(1, "DATABASE_URL is required"),
  SESSION_SECRET: z.string().min(16, "SESSION_SECRET should be >=16 chars"),
  ALLOW_ORIGINS: z.string().default("http://localhost:5173,http://127.0.0.1:5173"),
  OPENAI_API_KEY: z.string().optional(),
  REDIS_URL: z.string().optional(),
});

export const env = EnvSchema.parse(process.env);
export const isProd = env.NODE_ENV === "production";
export const allowedOrigins = env.ALLOW_ORIGINS.split(",").map(s => s.trim()).filter(Boolean);
```

**`.env.example`** (update our real `.env` accordingly)

```env
NODE_ENV=development
PORT=8080
DATABASE_URL=postgres://user:pass@host:5432/db
SESSION_SECRET=replace_me_with_long_random
ALLOW_ORIGINS=http://localhost:5173,https://<our-repl-app>.replit.app
OPENAI_API_KEY=
REDIS_URL=
```

---

## 2) Express App + CORS + Hardening

**`server/app.ts`**

```ts
import express from "express";
import helmet from "helmet";
import compression from "compression";
import morgan from "morgan";
import rateLimit from "express-rate-limit";
import cors from "cors";
import "express-async-errors";
import { allowedOrigins, isProd } from "./env";
import { router as vinsRouter } from "./routes/vins";
import { router as vehiclesRouter } from "./routes/vehicles";

export function buildApp() {
  const app = express();

  app.use(helmet({ crossOriginEmbedderPolicy: false, contentSecurityPolicy: false }));
  app.use(compression());
  app.use(morgan(isProd ? "combined" : "dev"));
  app.use(express.json({ limit: "1mb" }));

  const corsOptions: cors.CorsOptions = {
    origin(origin, cb) {
      if (!origin) return cb(null, true);
      if (allowedOrigins.includes(origin)) return cb(null, true);
      return cb(new Error(`CORS: origin ${origin} not allowed`));
    },
    credentials: true,
    methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With", "Accept"],
    exposedHeaders: ["ETag"],
    maxAge: 86400,
  };
  app.use((req, res, next) => {
    if (req.method === "OPTIONS") return cors(corsOptions)(req, res, next);
    return cors(corsOptions)(req, res, next);
  });

  app.get("/api/health", (_req, res) => res.json({ ok: true }));

  app.use("/api/v1/vins", vinsRouter);
  app.use("/api/v1/vehicles", vehiclesRouter);

  app.use((_req, res) => res.status(404).json({ error: "Not Found" }));

  app.use((err: any, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
    const code = typeof err?.status === "number" ? err.status : 500;
    const msg = isProd && code === 500 ? "Internal Server Error" : String(err?.message || err);
    if (!isProd) console.error(err);
    res.status(code).json({ error: msg });
  });

  app.use("/api/", rateLimit({ windowMs: 15 * 60_000, max: 300 }));

  return app;
}
```

**`server/index.ts`**

```ts
import { env } from "./env";
import { buildApp } from "./app";

const app = buildApp();
app.listen(env.PORT, () => {
  console.log(`Server listening on :${env.PORT}`);
});
```

Add script in `package.json` if missing:

```json
{
  "scripts": {
    "server": "tsx server/index.ts"
  }
}
```

---

## 3) Drizzle Schema (Vehicles + ai\_insights + VIN unique)

> If we already have a schema file, **align types** and ensure `ai_insights` is optional and VIN has a **unique constraint** at the DB level.

**`server/db/schema.ts`**

```ts
import { pgTable, text, uuid, timestamp, jsonb, index, unique } from "drizzle-orm/pg-core";

export type AiInsights = {
  summary: string;
  funFact?: string;
  market?: { estAuctionPriceUSD?: number; compsNote?: string };
};

export const vehicles = pgTable(
  "vehicles",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    vin: text("vin").notNull(),
    nickname: text("nickname"),
    year: text("year"),
    make: text("make"),
    model: text("model"),
    currentOwnerId: text("current_owner_id").notNull(),
    aiInsights: jsonb("ai_insights").$type<AiInsights | null>().default(null),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
  },
  (t) => ({
    vinUnique: unique("vehicles_vin_unique").on(t.vin),
    ownerVinIdx: index("vehicles_owner_vin_idx").on(t.currentOwnerId, t.vin),
  })
);
```

**Migration (Postgres)** `server/drizzle/20250827_vin_unique_aiinsights.sql`

```sql
ALTER TABLE vehicles ADD COLUMN IF NOT EXISTS ai_insights jsonb;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'vehicles_vin_unique') THEN
    ALTER TABLE vehicles ADD CONSTRAINT vehicles_vin_unique UNIQUE (vin);
  END IF;
END$$;

CREATE INDEX IF NOT EXISTS vehicles_owner_vin_idx ON vehicles (current_owner_id, vin);
```

> **SQLite variant:**

```sql
ALTER TABLE vehicles ADD COLUMN ai_insights TEXT; -- if not exists, skip if error
CREATE UNIQUE INDEX IF NOT EXISTS vehicles_vin_unique ON vehicles(vin);
CREATE INDEX IF NOT EXISTS vehicles_owner_vin_idx ON vehicles(current_owner_id, vin);
```

---

## 4) VIN Utilities

**`server/lib/vin.ts`**

```ts
export function sanitizeVin(input: string): string {
  return (input || "").toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 17);
}

export function isPotentialVin(input: string): boolean {
  const v = sanitizeVin(input);
  return v.length === 17 && !/[IOQ]/.test(v);
}
```

---

## 5) vPIC Proxy + AI Insights Endpoints

**`server/routes/vins.ts`**

```ts
import { Router } from "express";
import fetch from "node-fetch";
import { sanitizeVin, isPotentialVin } from "../lib/vin";
import { promptInsights } from "../services/insights";

export const router = Router();

router.get(":vin/decode", async (req, res) => {
  const vin = sanitizeVin(String(req.params.vin));
  if (!isPotentialVin(vin)) return res.status(400).json({ error: "Invalid VIN" });

  const url = `https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVin/${vin}?format=json`;
  const r = await fetch(url, { headers: { "user-agent": "VINtage/1.0" } });
  if (!r.ok) return res.status(502).json({ error: `vPIC error: ${r.status}` });
  const data = await r.json();

  const result = (data?.Results || []).reduce((acc: any, row: any) => {
    if (row?.Variable && row?.Value) acc[row.Variable] = row.Value;
    return acc;
  }, {} as Record<string, string>);

  res.setHeader("Cache-Control", "public, max-age=3600");
  return res.json({ vin, result });
});

router.get(":vin/insights", async (req, res) => {
  const vin = sanitizeVin(String(req.params.vin));
  if (!isPotentialVin(vin)) return res.status(400).json({ error: "Invalid VIN" });

  const decoded = await (await fetch(`https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVin/${vin}?format=json`)).json();
  const summary = await promptInsights(vin, decoded);
  return res.json({ vin, insights: summary });
});
```

**`server/services/insights.ts`**

```ts
import { env } from "../env";

export async function promptInsights(vin: string, decoded: unknown) {
  if (!env.OPENAI_API_KEY) {
    return { summary: "Set OPENAI_API_KEY to enable AI insights." } as any;
  }
  const OpenAI = (await import("openai")).default;
  const client = new OpenAI({ apiKey: env.OPENAI_API_KEY });

  const sys = `You are an automotive analyst. Write concise, factual insights. Use short bullets.`;
  const user = `VIN: ${vin}\nDecoded (may be partial): ${JSON.stringify(decoded).slice(0, 4000)}`;

  const resp = await client.chat.completions.create({
    model: "gpt-4o-mini",
    temperature: 0.2,
    messages: [
      { role: "system", content: sys },
      { role: "user", content: user + "\n\nReturn JSON with keys: summary (string), funFact (string?), market (object with estAuctionPriceUSD:number?, compsNote:string?)." },
    ],
    response_format: { type: "json_object" },
  });

  try {
    return JSON.parse(resp.choices[0]?.message?.content || "{}");
  } catch {
    return { summary: "Insight generation failed to parse." };
  }
}
```

---

## 6) Vehicles API with Duplicate Prevention

> **Note:** Point `db` import to our existing Drizzle client. If we don’t have one, create `server/db/client.ts` that exports a configured Drizzle instance.

**`server/routes/vehicles.ts`**

```ts
import { Router } from "express";
import { z } from "zod";
import { eq } from "drizzle-orm";
import { vehicles } from "../db/schema";
import { db } from "../db/client"; // ensure this path matches our project
import { sanitizeVin, isPotentialVin } from "../lib/vin";

const CreateVehicle = z.object({
  vin: z.string(),
  nickname: z.string().optional(),
  year: z.string().optional(),
  make: z.string().optional(),
  model: z.string().optional(),
});

export const router = Router();

router.get("/check", async (req, res) => {
  const vin = sanitizeVin(String(req.query.vin || ""));
  if (!isPotentialVin(vin)) return res.json({ vin, exists: false });
  const [row] = await db.select().from(vehicles).where(eq(vehicles.vin, vin)).limit(1);
  return res.json({ vin, exists: Boolean(row) });
});

router.post("/", async (req, res) => {
  const parsed = CreateVehicle.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ error: parsed.error.flatten() });

  const vin = sanitizeVin(parsed.data.vin);
  if (!isPotentialVin(vin)) return res.status(400).json({ error: "Invalid VIN" });

  const [existing] = await db.select().from(vehicles).where(eq(vehicles.vin, vin)).limit(1);
  if (existing) return res.status(409).json({ error: "This VIN is already registered." });

  try {
    const [inserted] = await db
      .insert(vehicles)
      .values({
        vin,
        nickname: parsed.data.nickname || null,
        year: parsed.data.year || null,
        make: parsed.data.make || null,
        model: parsed.data.model || null,
        currentOwnerId: "replit-auth-user" // TODO: replace with session user id
      })
      .returning();

    return res.status(201).json({ vehicle: inserted });
  } catch (err: any) {
    const msg = String(err?.message || err);
    const isUnique = msg.includes("vehicles_vin_unique") || msg.includes("unique constraint") || msg.includes("SQLITE_CONSTRAINT_UNIQUE") || msg.includes("23505");
    if (isUnique) return res.status(409).json({ error: "This VIN is already registered." });
    throw err;
  }
});
```

---

## 7) Replit Auth Integration (Adapter)

> Keep our current Replit Auth. Add a tiny adapter so routes can call `requireAuth`/`optionalAuth` without changing business logic.

**`server/auth/replitAuth.ts`**

```ts
import type { Request, Response, NextFunction } from "express";

export type SessionUser = { id: string; name?: string | null; email?: string | null };

declare global {
  namespace Express { interface Request { user?: SessionUser | null } }
}

// TODO: Replace the internals with our actual Replit session lookup.
async function getSessionUser(req: Request): Promise<SessionUser | null> {
  // Examples (replace with real impl):
  // - from cookie: const token = req.cookies?.replit_session
  // - from header: const uid = req.header("x-replit-user-id")
  // return uid ? { id: uid } : null;
  return null; // placeholder to keep behavior unchanged until wired
}

export function optionalAuth() {
  return async (req: Request, _res: Response, next: NextFunction) => {
    try { req.user = await getSessionUser(req); } catch { req.user = null; }
    next();
  };
}

export function requireAuth() {
  return async (req: Request, res: Response, next: NextFunction) => {
    try { req.user = await getSessionUser(req); } catch { req.user = null; }
    if (!req.user) return res.status(401).json({ error: "Unauthorized" });
    next();
  };
}
```

> **How it integrates:** Wherever we need a user, call `requireAuth()` on the route. Replace the placeholder `getSessionUser` with our real Replit session extraction. This preserves our current auth model while giving us a clean abstraction.

---

## 8) Frontend Wiring (minimal)

**VIN duplicate check & decoder** — we will:

* Call `GET /api/v1/vehicles/check?vin=...` on VIN input (debounced) and show availability.
* Call `GET /api/v1/vins/:vin/decode` from the Decoder page (no CORS issues now).

*(Use the AddVehicle form + Decoder page from the previous canvas; only the API base path changed to `/api/v1/...`.)*

**Vite dev proxy** (already set):

```ts
server: { proxy: { "/api": { target: "http://localhost:8080", changeOrigin: true } } }
```

---

## 9) Migration Strategy & Rollback Plan

**A) Pre‑flight — find duplicates (Postgres)**

```sql
-- Find VINs that appear more than once
SELECT vin, COUNT(*) AS c
FROM vehicles
GROUP BY vin
HAVING COUNT(*) > 1
ORDER BY c DESC;

-- Inspect the rows to decide which one to keep
SELECT * FROM vehicles WHERE vin = '<DUPVIN>' ORDER BY updated_at DESC;
```

**B) Remediate duplicates**

* **Policy:** Keep the most recently updated row (`updated_at` desc), archive the others.
* Create an archive table:

```sql
CREATE TABLE IF NOT EXISTS vehicles_archive AS TABLE vehicles WITH NO DATA;
```

* For each duplicate VIN:

```sql
WITH ranked AS (
  SELECT id, vin, ROW_NUMBER() OVER (PARTITION BY vin ORDER BY updated_at DESC) AS rn
  FROM vehicles
)
INSERT INTO vehicles_archive SELECT v.* FROM vehicles v WHERE v.id IN (SELECT id FROM ranked WHERE rn > 1);

DELETE FROM vehicles
WHERE id IN (
  SELECT id FROM (
    SELECT id, ROW_NUMBER() OVER (PARTITION BY vin ORDER BY updated_at DESC) AS rn
    FROM vehicles
  ) t
  WHERE t.rn > 1
);
```

**C) Add the unique constraint** (from migration file), then validate:

```sql
-- Should return zero rows
SELECT vin FROM vehicles GROUP BY vin HAVING COUNT(*) > 1;
```

**D) Rollback plan**

* If constraint addition fails in production: **do not** leave a half‑applied state.
* Wrap in a transaction (if your migration runner supports it). If already applied and causing issues:

```sql
ALTER TABLE vehicles DROP CONSTRAINT IF EXISTS vehicles_vin_unique;
-- Investigate offending rows, remediate, re‑apply later
```

---

## 10) Incremental Rollout Plan

1. **Phase 1 — CORS Proxy**

   * Ship `server/app.ts`, `routes/vins.ts`, health route.
   * Verify decoder works via `/api/v1/vins/:vin/decode`.
2. **Phase 2 — Schema Safety**

   * Add `ai_insights` nullable column.
   * Ensure reads coalesce when missing.
3. **Phase 3 — Duplicate VIN Enforcement**

   * Run duplicate scan, archive extras, then add **unique(vin)**.
   * Ship `/vehicles/check` endpoint and UI guard.
4. **Phase 4 — AI Insights**

   * Set `OPENAI_API_KEY`; ship `/vins/:vin/insights`.
5. **Phase 5 — Security polish**

   * Rate limiting, logging, error handling already in place; tune thresholds.

---

## 11) Compatibility Notes (photo uploads, edit, dashboard)

* **Photo uploads** should key off `vehicle.id` (stable). No change required.
* **Vehicle editing** endpoints remain the same; new duplicate VIN guard only affects creation.
* **Dashboard** reads are unaffected. If it displays AI data, handle `aiInsights = null` gracefully.

---

## 12) Commands & Checks

**Install & run**

```bash
npm i helmet compression morgan express-rate-limit cors zod node-fetch openai
npm run server
```

**Smoke tests**

* `GET /api/health` → `{ ok: true }`
* Decode a real VIN → JSON with normalized keys.
* Try adding the same VIN twice → second call returns **409**.
* If `OPENAI_API_KEY` set → `/api/v1/vins/:vin/insights` returns structured JSON.

---

## 13) Answers to Specific Questions

**Q1. Auth middleware + Replit Auth?**

* Use `server/auth/replitAuth.ts` to expose `requireAuth`/`optionalAuth`. Replace `getSessionUser` with our real Replit session extraction (cookie or header). This isolates auth from route logic.

**Q2. Incremental vs Big‑bang?**

* **Incremental.** Phase 1 (CORS proxy) gives immediate stability. Phase 2 (schema safety) is low‑risk. Phase 3 (dup VIN) requires data remediation and is best done after we have metrics and backups. AI can follow once basics are stable.

**Q3. Rollback if VIN uniqueness conflicts?**

* Keep a pre‑migration backup or use `vehicles_archive`. If the constraint fails or breaks writes, **drop the constraint**, remediate duplicates, and re‑apply. The app‑level guard (409) still prevents new duplicates during the window.

---

## 14) Acceptance Criteria

* No client‑side CORS errors when decoding VINs.
* Database has `ai_insights` nullable and **unique(vin)** enforced.
* Creating a second vehicle with the same VIN returns **409** and is blocked in the UI.
* Existing photo uploads, edit flows, and dashboard work unchanged.
* AI insights return JSON (or a clear message when the key is missing).

---

**Done. Please proceed with the above steps, and report back with:**

* Output of the duplicate VIN scan,
* Confirmation of successful constraint creation,
* Any routes that still reference legacy paths so we can add compatibility shims if needed.
